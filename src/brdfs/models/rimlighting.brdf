analytic

# Rim lighting shader

# parameter block

::begin parameters
float rwidth 0 1 0.2
float dx 0 1 0
color cl 1 1 1
::end parameters

# shader code block

::begin shader

// Antialiased smoothstep(e0,e1,x).  
// Compute the box filter of smoothstep(e0,e1,t) from x-dx/2 to x+dx/2.
// Strategy: divide domain into 3 regions: t < e0, e0 <= t <= e1,
// and t > e1.  Region 1 has integral 0.  Region 2 is computed by
// analytically integrating smoothstep, which is -2t^3+3t^2.  Region 3
// is trivially 1.
//
float integral(float t)
{
    float t_squared = t * t;
    return -0.5 * t_squared * (t_squared - 2 * t);
}

float filteredsmoothstep(float e0, float e1, float x, float dx)
{
    // Compute x0, x1 bounding region of integration, and normalize so that
    // e0==0, e1==1
    float edgediff = e1 - e0;
    float x0 = (x - e0) / edgediff;
    float fw = dx / edgediff;
    x0 -= 0.5 * fw;
    float x1 = x0 + fw;

    // Region 1 always contributes nothing
    float i = 0;

    // Region 2 - compute integral in region between 0 and 1
    if (x0 < 1 && x1 > 0)
        i += (integral(min(x1, 1)) - integral(max(x0, 0)));

    // Region 3 - is 1.0
    if (x1 > 1)
        i += (x1 - max(1, x0));

    return i / fw;
}

// No need for rimlight function to return color;
// Just to show it in the brdf explorer;
vec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y)
{
    if (dx == 0)
        return cl * smoothstep(1 - rwidth, 1, 1 - max(dot(V, N), 0));
    else
        return cl * filteredsmoothstep(1 - rwidth, 1, 1 - max(dot(V, N), 0), dx);
}