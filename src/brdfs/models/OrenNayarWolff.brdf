analytic

////////////////////////////////////////////////////////////////////////////////
// Oren-Nayar-Wolff diffuse model, based on the paper "Improved Diffuse ////////
// Reflection Models for Computer Vision", by Lawrence B. Wolff, Shree K. //////
// Nayar, Michael Oren, and on Larry Gritz's implementation of the full ////////
// Oren-Nayar model, with inter-reflections, from The RenderMan Repository /////
// http://www.renderman.org ////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/* "The diffuse reflection model proposed by Wolff, models reflection from
 * smooth dielectric materials as a combination of a subsurface light 
 * scattering distribution produced from internal inhomogeneities coupled
 * with the refraction of externally incident, and internally scattered
 * light at the air-surface dielectric boundary." */
/* The Oren-Nayar-Wolff implementation is based on the full model considering
 * inter-reflections. */

::begin parameters
float sigma 0 1 0.5
float ior   0 5 1.07
float nondiff 0 1 0.5
color cdiff 0.8 0.8 0.8
color cl 0.5 0.5 0.5
::end parameters

# shader code block

::begin shader

const float AIR = 1.000293; // ior for air
const float PI = 3.14159265358979323846;
const float TWO_PI = PI * 2;

// formula for the Fresnel reflection factor for unpolarized light
// Reference : http://www.oceanopticsbook.info/view/surfaces/the_level_sea_surface
float nfresnel(float costheta, float eta)
{
    float g2 = sqrt(eta * eta - 1 + costheta * costheta);
    float A = g2 - costheta;
    float B = g2 + costheta;
    float AA = B * costheta - 1;
    float BB = A * costheta + 1;
    return 0.5 * (A * A / (B * B)) * (1 + AA * AA / (BB * BB));
}

vec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y)
{
    // store preset quantities whenever possible
    float cos_theta_r = max(0, dot(V, N));
    float theta_r = acos(cos_theta_r);
    float sigma2 = sigma * sigma;

    float eta = AIR / ior;

    float cos_theta_i = max(0, dot(L, N));
    float cos_phi_diff = dot(normalize(V - N * cos_theta_r), normalize(L - N * cos_theta_i));
    float theta_i = acos(cos_theta_i);
    float alpha = max(theta_i, theta_r);
    float beta = min(theta_i, theta_r);

    // transmitted angle
    float cos_theta_tl = sqrt(max(0, 1 - eta * eta * (1 - cos_theta_i * cos_theta_i)));

    // 1st Oren-Nayar coefficient
    float c1 = (1 - 0.5 * sigma2 / (sigma2 + 0.33)) * (1 - nfresnel(cos_theta_i, ior) * (1 - nfresnel(cos_theta_tl, eta)));
    // 2nd coefficient
    float c2 = 0.45 * sigma2 / (sigma2 + 0.09);

    if (cos_phi_diff >= 0)
    {
        c2 *= sin(alpha);
    }
    else
    {
        c2 *= (sin(alpha) - pow(2 * beta / PI, 3));
    }
    // 3rd coefficient (Qualitative model ony uses c1 + c2)
    float c3 = 0.125 * sigma2 / (sigma2 + 0.09) * pow(4 * alpha * beta / TWO_PI, 2);

    // Final L1 term
    vec3 l1 = cdiff * (cos_theta_i * (c1 + cos_phi_diff * c2 * tan(beta) + (1 - abs(cos_phi_diff)) * c3 * tan((alpha + beta) / 2)));

    // Final L2 term
    vec3 l2 = (cdiff * cdiff) * (0.17 * cos_theta_i * sigma2 / (sigma2 + 0.13) * (1 - cos_phi_diff * 4 * beta * beta / TWO_PI));

    return cl * (1 - nondiff) * (l1 + l2);
}