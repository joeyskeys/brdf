analytic

////////////////////////////////////////////////////////////////////////////////
// Note: below follows the Ashikhmin-Shirley diffuse term, based on the ////////
// implementation by Peter Stuart, as well as further below, the specular //////
// term, for those wanting to experiment with things. The complete model is ////
// further below. Also note that the diffuse term and specular terms are ///////
// inter-dependent, but for the sake of giving the user the possibility to /////
// experiment a bit, i thought we could include the separate terms as well. ////
// So things were tweaked a bit, in order to fit shrimp's structure. ///////////
////////////////////////////////////////////////////////////////////////////////
// based on "An anisotropic Phong BRDF Model", by Michael Ashikhmin and ////////
// Peter Shirley ///////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/* 
 * ashshir.sl
 * Simple surface using Ashikmin-Shirley BRDF
 * Peter Stuart
 * $Id: ashshir.sl,v 1.4 2003/05/05 05:22:41 ophi Exp $
 * description: Ashikmin and Shirley BRDF lighting model as described
 * in "An Anisotropic Phong Light Reflection Model." Most of the work
 * is done in ashShirModel.h by two functions - one for dealing with
 * direct lighting, and the other for dealing with environment lighting.
 *
 * ---- surface parameters ----------
 * rd: diffuse reflectance
 * rs: specular reflectance
 * nu: specular exponent along xdir
 * nv: specular exponent perpendicular to xdir
 * refl: amount of reflection to use
 * envname: name of environment map to use. If this is "" the shader will
 *   try to raytrace the environment if there are samples (envsamp > 0)
 * envsamp: number of samples to use when sampling the environment
 * */

::begin parameters
float Kd 0 5 0.5
float Ks 0 5 0.5
float nondiff 0 1 0.5
color cl 0.5 0.5 0.5
::end parameters

# shader code block

::begin shader

const float PI = 3.14159265358979323846;

vec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y)
{
    float ndotv = max(0, dot(N, V));
    float ndotl = max(0, dot(N, L));

    return cl * (1 - nondiff) * (28 * Kd / (23 * PI)) * (1 - Ks) * (1 - pow(1 - ndotl / 2, 5)) * (1 - pow(1 - ndotv / 2, 5)) * ndotl;
}