analytic

// Oren-Nayar diffuse model, implementation by Larry Gritz, from //
// The RenderMan Repository - http://www.renderman.org ////////////
// This implementation is the 3 coefficients implementation with //
// inter-reflections //////////////////////////////////////////////

/* renamed LG_orennayar.sl -- tal AT renderman DOT org */
/*
 * orennayar.sl - rough diffuse surface
 *
 * 
 * DESCRIPTION:
 *   Makes a rough surface using a BRDF which is more accurate than
 *   Lambert.  Based on Oren & Nayar's model (see Proc. SIGGRAPH 94).
 *
 *   Lambertian (isotropic) BRDF is a simple approximation, but not
 *   an especially accurate one for rough surfaces.  Truly rough surfacs
 *   tend to act more like retroreflectors than like isotropic scatterers.
 * 
 * PARAMETERS:
 *   Ka, Kd - just like matte.sl
 *   sigma - roughness (0 is lambertian, larger values are rougher)
 *
 * AUTHOR:  Larry Gritz
 *
 * REFERENCES:
 *   Oren, Michael and Shree K. Nayar.  "Generalization of Lambert's
 *         Reflectance Model," Computer Graphics Annual Conference
 *         Series 1994 (Proceedings of SIGGRAPH '94), pp. 239-246.
 *
 * NOTES:
 *   1. Note that this is really just an illuminance loop that gathers
 *      light from the sources and applies Oren & Nayar's local reflectance
 *      model to the result.  It could easily be packaged up as a macro
 *      or a function and used in any other shader, in place of diffuse().
 *   2. Examination of why rough surfaces are not Lambertian will lead
 *      you to the solution to the famous "flat full moon" problem.
 *
 * HISTORY:
 *   14 June 1994 -- written by Larry Gritz
 *
 * */

// Reference: http://www.larrygritz.com/arman/shaders/ 

::begin parameters
float sigma 0 1 0.5
float nondiff 0 1 0.5
color cdiff 0.8 0.8 0.8
color cl 0.5 0.5 0.5
::end parameters

# shader code block

::begin shader

const float PI = 3.14159265358979323846;
const float TWO_PI = PI * 2;

vec3 BRDF(vec3 L, vec3 V, vec3 N, vec3 X, vec3 Y)
{
    // store preset quantites whenever possible
    float cos_theta_r = dot(V, N);
    float theta_r = acos(cos_theta_r);
    float sigma2 = sigma * sigma;
    float c1 = 1 - 0.5 * sigma2 / (sigma2 + 0.33);

    float cos_theta_i = max(dot(L, N), 0);
    float cos_phi_diff = dot(normalize(V - N * cos_theta_r), normalize(L - N * cos_theta_i));
    float theta_i = acos(cos_theta_i);
    float alpha = max(theta_i, theta_r);
    float beta = min(theta_i, theta_r);

    float c2 = 0.45 * sigma2 / (sigma2 + 0.09);

    if (cos_phi_diff >= 0)
    {
        c2 *= sin(alpha);
    }
    else
    {
        c2 *= (sin(alpha) - pow(2 * beta / PI, 3));
    }

    float c3 = 0.125 * sigma2 / (sigma2 + 0.09) * pow(4 * alpha * beta / TWO_PI, 2);

    vec3 l1 = cdiff * (cos_theta_i * (c1 + cos_phi_diff * c2 * tan(beta) + (1 - abs(cos_phi_diff)) * c3 * tan((alpha + beta) / 2)));
    vec3 l2 = cdiff * cdiff * (0.17 * cos_theta_i * sigma2 / (sigma2 + 0.13) * (1 - cos_phi_diff * 4 * beta * beta / TWO_PI));

    return cl * (1 - nondiff) * (l1 + l2);
}